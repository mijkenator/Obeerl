-module(obelisk_control_listener2).
-author('mijkenator@gmail.com').

-behaviour(gen_server).

%% External API
-export([start_link/2]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,
         code_change/3, acceptor_loop/1, call_loop/2]).

-record(state, {
                listener,       % Listening socket
                acceptor,       % Asynchronous acceptor's internal reference
                module,         % FSM handling module
                socket_o        % socket options array
               }).

%%--------------------------------------------------------------------
%% @spec (Port::integer(), Module) -> {ok, Pid} | {error, Reason}
%
%% @doc Called by a supervisor to start the listening process.
%% @end
%%----------------------------------------------------------------------
start_link(Port, Module) when is_integer(Port), is_atom(Module) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [Port, Module], []).

%%%------------------------------------------------------------------------
%%% Callback functions from gen_server
%%%------------------------------------------------------------------------

%%----------------------------------------------------------------------
%% @spec (Port::integer()) -> {ok, State}           |
%%                            {ok, State, Timeout}  |
%%                            ignore                |
%%                            {stop, Reason}
%%
%% @doc Called by gen_server framework at process startup.
%%      Create listening socket.
%% @end
%%----------------------------------------------------------------------
init([Port, Module]) ->
    process_flag(trap_exit, true),
    Opts = case application:get_env(obelisk, control_port_tls) of
        {ok, true} ->
                        [binary, {packet, 2}, {reuseaddr, true}, {keepalive, true},
                        {backlog, 30}, {active, false}, {use_ssl, true},
                        {depth, 2},
                        {certfile,   "../server-cert.pem"}, 
                        {keyfile,    "../server-key.pem"},
                        {cacertfile, "../cacert.pem"}];
        _          ->
                        [binary, {packet, 2}, {reuseaddr, true}, {keepalive, true},
                        {backlog, 30}, {active, false}]
    end,
    io:format("control listener DEBUG 1 ~n"),
    case mijktcp:listen(Port, Opts) of
    {ok, Listen_socket} ->
        %%Create first accepting process
        io:format("control listener DEBUG 11 ~n"),
        Pid = proc_lib:spawn_link(?MODULE, acceptor_loop, [{self(), Listen_socket, Opts}]),
        {ok, #state{listener = Listen_socket,
                        module   = Module,
                        socket_o = Opts,
                        acceptor = Pid
                        }};
    {error, Reason} ->
        io:format("control listener DEBUG Errro accept ~n"),
        {stop, Reason}
    end.

%%-------------------------------------------------------------------------
%% @spec (Request, From, State) -> {reply, Reply, State}          |
%%                                 {reply, Reply, State, Timeout} |
%%                                 {noreply, State}               |
%%                                 {noreply, State, Timeout}      |
%%                                 {stop, Reason, Reply, State}   |
%%                                 {stop, Reason, State}
%% @doc Callback for synchronous server calls.  If `{stop, ...}' tuple
%%      is returned, the server is stopped and `terminate/2' is called.
%% @end
%% @private
%%-------------------------------------------------------------------------
handle_call(Request, _From, State) ->
    {stop, {unknown_call, Request}, State}.

%%-------------------------------------------------------------------------
%% @spec (Msg, State) ->{noreply, State}          |
%%                      {noreply, State, Timeout} |
%%                      {stop, Reason, State}
%% @doc Callback for asyncrous server calls.  If `{stop, ...}' tuple
%%      is returned, the server is stopped and `terminate/2' is called.
%% @end
%% @private
%%-------------------------------------------------------------------------
handle_cast(Msg, State) ->
    io:format("control listener 2 cast message ~p ~n", [Msg]),
    {noreply, State}.

%%-------------------------------------------------------------------------
%% @spec (Msg, State) ->{noreply, State}          |
%%                      {noreply, State, Timeout} |
%%                      {stop, Reason, State}
%% @doc Callback for messages sent directly to server's mailbox.
%%      If `{stop, ...}' tuple is returned, the server is stopped and
%%      `terminate/2' is called.
%% @end
%% @private
%%-------------------------------------------------------------------------
%handle_info({inet_async, _ListSock, _Ref, {ok, _CliSocket}},
%            #state{listener=_ListSock, acceptor=_Ref,
%                                    module=_Module, socket_o=_Options} = State) ->
%    io:format("handle info debug 111111 ok ~p ~n", [State]),
%    {ok, State}.
%
%handle_info({inet_async, ListSock, Ref, Error}, #state{listener=ListSock, acceptor=Ref} = State) ->
%    error_logger:error_msg("Error in socket acceptor: ~p.\n", [Error]),
%    logger:log({error, "listener: Error in socket acceptor"}),
%    {stop, Error, State};

handle_info(Info, State) ->
    io:format("handle info debug 111111 ok ~p ~p ~n", [Info, State]),
    {noreply, State}.

%%-------------------------------------------------------------------------
%% @spec (Reason, State) -> any
%% @doc  Callback executed on server shutdown. It is only invoked if
%%       `process_flag(trap_exit, true)' is set by the server process.
%%       The return value is ignored.
%% @end
%% @private
%%-------------------------------------------------------------------------
terminate(_Reason, State) ->
%gen_tcp:close(State#state.listener),
    mijktcp:close(State#state.listener, State#state.socket_o),
    ok.

%%-------------------------------------------------------------------------
%% @spec (OldVsn, State, Extra) -> {ok, NewState}
%% @doc  Convert process state when code is changed.
%% @end
%% @private
%%-------------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%------------------------------------------------------------------------
%%% Internal functions
%%%------------------------------------------------------------------------

%% Taken from prim_inet.  We are merely copying some socket options from the
%% listening socket to the new client socket.
%set_sockopt(ListSock, CliSocket, Options) ->
%    true = inet_db:register_socket(CliSocket, inet_tcp),
%    case prim_inet:getopts(ListSock, [active, nodelay, keepalive, delay_send, priority, tos]) of
%    {ok, Opts} ->
%        case prim_inet:setopts(CliSocket, Opts) of
%        ok    -> ok;
%        %Error -> gen_tcp:close(CliSocket), Error
%        Error -> mijktcp:close(CliSocket, Options), Error
%        end;
%    Error ->
%        %gen_tcp:close(CliSocket), Error
%        mijktcp:close(CliSocket, Options), Error
%        
%    end.

acceptor_loop({Server, Listen_socket, Opts}) ->
    %logger:log({debug, "listener 2: acceptor loop 1"}),
    io:format("listener 2: acceptor loop 1 ~n"),
    case catch mijktcp:accept(Listen_socket, Opts) of
        {ok, Socket} ->
            %logger:log({debug, "listener 2: acceptor loop 2"}),
            io:format("listener 2: acceptor loop 2 ~n"),
            gen_server:cast(Server, {accepted, self()}),
            %logger:log({debug, "listener 2: acceptor loop 3"}),
            io:format("listener 2: acceptor loop 3 ~n"),
            call_loop(Socket, Opts);
        {error, closed} ->
            exit({error, closed});
        Other ->
            io:format("acceptor loop error ERROR ~p ~n", [Other]),
            exit({error, accept_failed})
    end.
    


call_loop(Socket, Opts) ->
    %logger:log({debug, "listener 2: call loop 1"}),
    io:format("listener 2: call loop 1 ~n"),
    case mijktcp:recv(Socket, 0, 30000, Opts) of
        {ok, Data} ->
            case mijktcp:send(Socket, Data, Opts) of
                ok ->
                    call_loop(Socket, Opts);
                _ ->
                    exit(normal)
            end;
        _Other ->
            exit(normal)
    end.
    